#descargar la imagen de node a local antes: 

docker pull node:10-alpine

FROM node:10-alpine
#Comando. docker build . en consola en la carpeta del archivo para que construya el archivo
#Comprobar creacion con: docker images
#Asignar etiqueta (tag) con: docker build -t uv/frontuv:1.0 .
#docker run -d --name frontuv_container (este es el contenedor) frontuv:1.0 (esta es la imagen) para crear
#Para modificar la imagen, hay que borrar los contenedores de esta
#Levantar la imagen con  
#docker rm frontuv_container para borrar contenedor
#docker image rm frontuv para borrar imágenes
#docker image rm uv/frontuv:1.0
#RUN es para ejecutar dentro del contenedor, node:node es grupo y usuarios
RUN mkdir -p /home/node/app/node_modules && chown -R node:node /home/node/app 
#Carpeta de node, la ejecución es dentro del mismo contenedor que se ha creado
RUN mkdir /home/node/app/uvfiles && chown -R node:node /home/node/app/uvfiles
#Correr en consola docker build -t frontuv:1.0 .
WORKDIR /home/node/app
COPY hello.html ./
#Si hubiera archivos de estos, se copian a raiz (home/node/app)
USER node
#te cambias al usuario node dentro del contenedor
RUN npm install
#Se corre con el docker build -t frontuv:1.0 .
EXPOSE 8080
CMD ["node", "Node.js"]
#Hasta ahora solo se hace la imagen y sin mapear ni meter contenido al contenedor
#docker run -d --name frontuv_container frontuv:1.0

#Para subir la imagen, una vez ya creada:

Crear un repositorio en docker hub público:

Ejemplo: front_test

A la imagen ya creada se le reasigna un tag para que la lea el docker push.

docker tag front:1.0 usuario/repositorio:tag
Ejemplo: docker tag front:1.0 guachi10/front_test:1.0

Comprobar con docker images que se reasignó 

Repository                      Tag
guachi10/front_test             1.0

docker push guachi10/postgrestest:1.0


Clase del viernes 21 de abril de 2023:

terminal en docker file/

mkdir database
cd database
ls

/database

nano initdb.sql

/initdb.sql

CREATE USER myuser;
CREATE DATABASE mydb;
GRANT ALL PRIVILEGES ON DATABASE mydb TO myuser;

cat initdb.sql

nano Dockerfile
/Dockerfile

FROM postgres:12
COPY inittdb.sql /docker-entrypoint-initdb.d/

ls

Dockerfile initdb.sql

nano build.sh

/build.sh

docker build  -t usuario/postgresuv:1.0 .

-t =asigna la etiqueta
usuario = cuenta de docker hub.
postgresuv = nombre de la imagen
1.0: Versión del script.

chmod 755 build.sh
permisos de ejecución

./build.sh = compilación rápida con privilegios.

docker images

La imagen debería estar creada.

docker push usuario/postgresuv:1.0

Ahora en DockerHub:

Debería verse la imagen ahí.

ls

/docker-file/database

build.sh   Dockerfile   initdb.sql

docker ps -a lista de procesos

antes de borrar, detener el contenedor con docker stop

docker stop mipostgres12_container
docker rm mipostgres12_container

docker images

docker run  --name postgres_uvcontainer -e POSTGRES_PASSWORD=potsgres -d usuario/postgresuv:1.0

comprobar que se creó con docker ps.

docker logs postgres_uvcontainer (login al contenedor)

docker exec -it postgres_uvcontainer  /bin/bash
su postgres (usuario del so)
psql

\l

muestra las bases de datos en un tabla.

Lunes 24 de abril

Crear carpeta al lado de frontapp llamado Practica08 y ahí metes el proyecto de java.

cd Practica08

Descargar antes la imagen de eclipse-temurin:11

docker pull eclipse-temurin:11

nano DockerFile

ls

practica08 dockerfile

/dockerfile

FROM eclipse-temurin:11
RUN mkdir -p /opt/app 
WORKDIR /opt/app 
ARG JAR_FILE=target/Programa08-0.0.1-SNAPSHOT.jar
COPY ${JAR_FILE} app.jar
EXPOSE 8080
ENTRYPOINT [“java”, “-jar”, “app.jar”]

docker build -t usuario/backuv:1.0 .

nano build.sh

./build.sh

chmod +x build.sh

igual ejecutarlo en consola: chmod +x build.sh

Pasar al modo sudo si no jala.

./build.sh

docker images

(docker login por si no lo has has hecho)

#Para subir la imagen, una vez ya creada:

Crear un repositorio en docker hub público:

Ejemplo: back_test

A la imagen ya creada se le reasigna un tag para que la lea el docker push:

docker tag front:1.0 usuario/repositorio:tag
Ejemplo: docker tag back:1.0 guachi10/back_test:1.0

Comprobar con docker images que se reasignó 

Repository                      Tag
guachi10/back_test             1.0

docker push guachi10/back_test:1.0

docker run --name backuv_container -d -e#-e SPRING_DATASOURCE_URL=jdbc:postgresql://172.17.0.4:5432/mydb usuario_bd/backuv:1.0
o
docker run --name back_container -d -e SPRING_DATASOURCE_URL=jdbc:postgresql://172.17.0.4:5432/mydb guachi10/back_test:1.0

docker rm backuv_container

se levantan dos contenedores, el front y back.
probar en localhost con 172.17.0.5:5432

docker logs postgresuv_container
docker run --name mipostgres12 -e POSTGRES_PASSWORD=postgres -d postgres:12
